/*
Acqurie the uuid modules for the unique id.
Acqurie the verifySignature method for the transaction verification
Acquire the cryptoHash module for hashing functionality & cryptoRandomID for random ID geneator.
Acquire the hardcoded REWARD INPUTS and MINING REWARDS
*/
//const uuid = require('uuid/v4');
const { REWARD_INPUT, MINING_REWARD } = require('../config');
const { verifySignature, cryptoHash, cryptoRandomID } = require('../util');

class Transaction {

    constructor({ senderWallet, receiver, amount, outputMap, input }) {

        //Create a random ID for the transaction
        this.id = cryptoRandomID(64);

        //OutputMap trigger by calling the helper method and passing in the object
        //If outputMap is undefinied, it would createOutputMap. Else use the incoming outputMap.
        this.outputMap = outputMap || this.createOutputMap({ senderWallet, receiver, amount });

        //input trigger by calling the helper method and passing in the object.
        //If outputMap is undefinied, it would createInput. Else used the incoming input
        this.input = input || this.createInput({ senderWallet, outputMap: this.outputMap });

        //Hash the transaction with the ID and the output and input of the transactions.
        this.hash = cryptoHash(cryptoHash(this.outputMap, this.input, this.id));
    }

    /*
    Helper method to create the outputMap.
    Take in the object with the senderWallet, receiver and amount.
    */
    createOutputMap({ senderWallet, receiver, amount }) {

        const outputMap = {};

        //Receiver is taking the amount.
        outputMap[receiver] = amount;

        //Deduction from the sender. Balance - amount to be send.
        outputMap[senderWallet.publicKey] = senderWallet.balance - amount;

        return outputMap;
    }

    /*
    Helper method to create the inputs. 
    senderWallet - require for the signature
    outputMap - data which is to be sign that part of this transaction
    */
    createInput({ senderWallet, outputMap, }) {
        return {

            //Return the timestamp 
            timestamp: Math.floor(Date.now() / 1000),
            amount: senderWallet.balance,
            address: senderWallet.publicKey,
            signature: senderWallet.sign(outputMap)
        };
    }


    /*
    Validates the transaction
    */
    static validTransaction(transaction) {
        //Destructure input and the transaction strcture.
        const {
            id,
            input: { address, amount, signature },
            outputMap,
            hash
        } = transaction;

        //Check all the values in the outputMap but reduce the 
        //array into a single value.
        const outputTotal = Object.values(outputMap)
            .reduce((total, outputAmount) => total + outputAmount);

        //Function return false if is invalid
        //Check if the hashing of the input, output and id meet the hash of the transaction.
        if (cryptoHash(cryptoHash(transaction.outputMap, transaction.input, transaction.id)) != transaction.hash) {
            console.error(`Invalid Transaction hash from this : ${address}.`);
            return false;
        }

        //Check the overrall outputTotal equals to the amount.
        if (amount !== outputTotal) {
            console.error(`Invalid Transaction from this : ${address}.`);
            return false;
        }
        //Check if the signature is valid.
        if (!verifySignature({ publicKey: address, data: outputMap, signature })) {
            console.error(`Invalid Signature from this : ${address}`);
            return false;
        }

        return true;
    }

    /*
    Ensure that miner is able to get thier incentive reward (Miner Reward).
    Also it consist on an input (shouldnt be generated by specific Wallet; Hardcoded Values) 
    and outputMap(Straight forward, Miner PublicKey)
    */
    static rewardTransaction({ minerWallet }) {
        return new this({
            input: REWARD_INPUT,
            outputMap: {
                [minerWallet.publicKey]: MINING_REWARD
            }
        });
    }

    /*
    Update function having the ability to add new amount 
    within the transaction ouputMap for a new recevier. 
    */
    update({ senderWallet, receiver, amount }) {

        /*
        Ensure that if the amount is lesser than the amount in the sender wallet.
        Case when senderWallet does not have enough amount.
        */
        if (amount > this.outputMap[senderWallet.publicKey]) {
            throw new Error('Amount exceeds balance');
        }

        //If the receiver is not within the outputMap
        if (!this.outputMap[receiver]) {
            //Designate the amount to the next receiver. (Not repeated receiver) 
            this.outputMap[receiver] = amount;
        } else {
            //Repeated receiver or already exisit, hence add the amount instead of overwriting. 
            this.outputMap[receiver] = this.outputMap[receiver] + amount;
        }

        //Subtract new amount from the senderWallet publicKey.
        this.outputMap[senderWallet.publicKey] =
            this.outputMap[senderWallet.publicKey] - amount;

        //Recreate the input field by resign.
        this.input = this.createInput({ senderWallet, outputMap: this.outputMap });

        //Rehash the transaction upon update of new transaction from same user.
        this.hash = cryptoHash(cryptoHash(this.outputMap, this.input, this.id));
    }
}

module.exports = Transaction;